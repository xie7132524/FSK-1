/**********************************************************************
* © 2007 Microchip Technology Inc.
*
* FileName:        Si3000CodecDrv.c
* Dependencies:    Header (.h) files if applicable, see below
* Processor:       dsPIC30Fxxxx/dsPIC33Fxxxx
* Compiler:        MPLAB® C30 v3.00 or higher
*
* SOFTWARE LICENSE AGREEMENT:
* Microchip Technology Incorporated ("Microchip") retains all ownership and 
* intellectual property rights in the code accompanying this message and in all 
* derivatives hereto.  You may use this code, and any derivatives created by 
* any person or entity by or on your behalf, exclusively with Microchip's
* proprietary products.  Your acceptance and/or use of this code constitutes 
* agreement to the terms and conditions of this notice.
*
* CODE ACCOMPANYING THIS MESSAGE IS SUPPLIED BY MICROCHIP "AS IS".  NO 
* WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
* TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A 
* PARTICULAR PURPOSE APPLY TO THIS CODE, ITS INTERACTION WITH MICROCHIP'S 
* PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION. 
*
* YOU ACKNOWLEDGE AND AGREE THAT, IN NO EVENT, SHALL MICROCHIP BE LIABLE, WHETHER 
* IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), 
* STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT, SPECIAL, 
* PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, FOR COST OR EXPENSE OF 
* ANY KIND WHATSOEVER RELATED TO THE CODE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN 
* ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE FULLEST EXTENT 
* ALLOWABLE BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO 
* THIS CODE, SHALL NOT EXCEED THE PRICE YOU PAID DIRECTLY TO MICROCHIP SPECIFICALLY TO 
* HAVE THIS CODE DEVELOPED.
*
* You agree that you are solely responsible for testing the code and 
* determining its suitability.  Microchip has no obligation to modify, test, 
* certify, or support the code.*/
/**************************************************************************************/


#include "..\h\Si3000CodecDrv.h"

Si3000CodecHandle *thisCodec;

void Si3000CodecInit(Si3000CodecHandle *pHandle,int* pBuffer)
{
	int i;
	
	#if(DCI_MASTER)
		DCICON1 = 0x0040;
		DCICON2 = 0x00EF;
		DCICON3 = DCI_BRG_VALUE;
		RSCON 	= 0x01;
		TSCON	= 0x01;
	#endif
	
	// Flush the buffers
	for (i = 0; i < SI3000_DRV_BUFFER_SIZE; i++)
	{
		pBuffer[i] = 0;
	}
		
	thisCodec = pHandle;
	thisCodec->inputBuffer1 	= pBuffer;
	thisCodec->inputBuffer2 	= pBuffer + SI3000_CODEC_FRAME;
	thisCodec->outputBuffer1 	= pBuffer + (2*SI3000_CODEC_FRAME);
	thisCodec->outputBuffer2 	= pBuffer + (3*SI3000_CODEC_FRAME);
	SI3000_RESET_PIN_TRIS = 0;
	SI3000_RESET_PIN = 1;

	_DCIIF = 0;
	_DCIIP = DCI_INTERRUPT_PRIORITY;
	_DCIIE = 1;
}

void Si3000CodecStart(Si3000CodecHandle *pHandle, Si3000CodecRegisters *pRegisters)
{
	int reset;
	pHandle->statusFlag 			= 0;
	pHandle->statusFlag				|= SET_READ_BUSY;
	pHandle->statusFlag				|= SET_WRITE_BUSY;
	pHandle->activeInputBuffer 		= pHandle->inputBuffer1;
	pHandle->activeOutputBuffer 	= pHandle->outputBuffer1;
	pHandle->commandValue 			= 0;
	pHandle->command				= DEFAULT_COMMAND;
	pHandle->currentSampleIndex		= 0;
	pHandle->currentFrameSize 		= SI3000_CODEC_FRAME - 1;
	pHandle->newFrameSize			= SI3000_CODEC_FRAME - 1;
	TXBUF0 							= pHandle->activeOutputBuffer[0] | 0x0001;
	
	SI3000_RESET_PIN = 1;
	
	for(reset = 0; reset <= SI3000_RESET_DURATION; reset++)
	{
		SI3000_RESET_PIN = 0;
	}
	
	SI3000_RESET_PIN = 1;
	
	// Enable the DCI
	DCICON1bits.DCIEN = 1;

	pRegisters->control1 			= 0x0018; 
	pRegisters->control2 			= 0x0000;
	// MCLK generated by the dsPIC is 2MHz so divide by 25 and multiply by 512
	// Si3000 adds 1 to N1 and M1 so subtract 1 here.
	pRegisters->pll1DivideN1 		= 25 - 1;
	pRegisters->pll1MultiplyM1		= 512 - 1;
	pRegisters->rxGainControl1		= 0x006A;
	pRegisters->adcVolumeControl 	= 0x005E; 
	pRegisters->dacVolumeControl 	= 0x005F; 
	pRegisters->analogAttenuation	= 0x0000; 

	// Setup the Si3000 codec.
	pRegisters->control1 			= 0x0080;				// Reset the Si3000 to defaults
	Si3000CodecIOCtl (pHandle, CONTROL_1_WRITE,				&pRegisters->control1);
	Si3000CodecIOCtl (pHandle, PLL1_DIVIDE_N1_WRITE,		&pRegisters->pll1DivideN1);
	Si3000CodecIOCtl (pHandle, PLL1_MULTIPLY_M1_WRITE,		&pRegisters->pll1MultiplyM1);
	Si3000CodecIOCtl (pHandle, CONTROL_2_WRITE,				&pRegisters->control2);
	Si3000CodecIOCtl (pHandle, RX_GAIN_CONTROL_1_WRITE, 	&pRegisters->rxGainControl1);
	Si3000CodecIOCtl (pHandle, ADC_VOLUME_CONTROL_WRITE,	&pRegisters->adcVolumeControl);
	Si3000CodecIOCtl (pHandle, DAC_VOLUME_CONTROL_WRITE,	&pRegisters->dacVolumeControl);
	Si3000CodecIOCtl (pHandle, ANALOG_ATTENUATION_WRITE, 	&pRegisters->analogAttenuation);
	pRegisters->control1 			= 0x0018;
	Si3000CodecIOCtl (pHandle, CONTROL_1_WRITE,				&pRegisters->control1);
}

void Si3000CodecRead(Si3000CodecHandle *pHandle,int * data, int size)
{
	/* The buffer indicator bit in the status register determines which	
	 * which buffer can be read. If flag is 0 then buffer 2 should be read
	 * else buffer should be read. */
	 
	 int* source;
	 int sampleIndex;
	 
	 if((pHandle->statusFlag & GET_BUFFER_IND) == 0)
	 {
		 /* This means that buffer 1 is busy and buffer 2 is 
		  * available to read	*/
		source = pHandle->inputBuffer2;
	}
	else
	{
		/* This means that buffer 2 is busy and buffer 1 is 
		  * available to read	*/
		source = pHandle->inputBuffer1;
	}
		  
	if (size > SI3000_CODEC_FRAME)
	{
		size = SI3000_CODEC_FRAME;
	}
		
	for(sampleIndex = 0; sampleIndex < size; sampleIndex++)
	{
		data[sampleIndex] = source[sampleIndex];
	}
	
	/* Set the read busy flag indicating that no buffers are 
	 * available for reading	*/
	 
	__asm__ volatile("disi #0x4"); /* disable interrupts */
	pHandle->statusFlag |= SET_READ_BUSY;
	__asm__ volatile("disi #0x0"); /* enable interrupts */
	
}


void Si3000CodecWrite(Si3000CodecHandle *pHandle,int * data, int size)
{
	/* The buffer indicator bit in the status register determines which	
	 * which buffer can be written to. If flag is 0 then buffer 2 should be 
	 * written to since the driver is writing buffer 1 to the output. */
	 
	 int* destination;
	 int  sampleIndex;
	 
	 if((pHandle->statusFlag & GET_BUFFER_IND) == 0)
	 {
		 /* This means that buffer 1 is busy and buffer 2 is 
		  * available to write to	*/
		 destination = pHandle->outputBuffer2;
	}
	else
	{
		/* This means that buffer 2 is busy and buffer 1 is 
		 * available to write to	*/
		destination = pHandle->outputBuffer1;
	}
		  
	if (size > SI3000_CODEC_FRAME)
	{
		size = SI3000_CODEC_FRAME;
	}
	
	/* Update the frame size. The actual switch will happen
	 * in the ISR	*/	
	pHandle->newFrameSize = size;
		
	for(sampleIndex = 0; sampleIndex < size; sampleIndex++)
	{
		destination[sampleIndex] = data[sampleIndex];
	}
	
	/* Set the write busy flag indicating that no buffers are 
	 * available for writing	*/
	__asm__ volatile("disi #0x4"); /* disable interrupts */
	pHandle->statusFlag |= SET_WRITE_BUSY;
	__asm__ volatile("disi #0x0"); /* enable interrupts */
}

int Si3000CodecWriteBusy(Si3000CodecHandle *pHandle)
{
	return( ((pHandle->statusFlag & GET_WRITE_BUSY) == 0) ? 0 : 1); 
}

int  Si3000CodecReadBusy(Si3000CodecHandle *pHandle)
{
	return( ((pHandle->statusFlag & GET_READ_BUSY) == 0) ? 0 : 1); 
}

void Si3000CodecIOCtl(Si3000CodecHandle *pHandle, int command, void * data)
{
	/* This function is blocking. It will wait till the previous
	 * command was executed	*/
	
	while((thisCodec->statusFlag & GET_CANSEND_CMD) == 0);
	while((thisCodec->statusFlag & GET_COMMAND_REQ) != 0);
	pHandle->command = command;
	
	if((command & IS_READ_COMMAND) != 0)	
	{
		/* For a read command, ignore the data value	*/
		pHandle->commandValue = 0;		
	}
	else
	{
		/* A SET command has been sent */
		pHandle->commandValue = *((int*) data);
	}
	
	pHandle->statusFlag |= SET_COMMAND_REQ;
	/* Wait till this command executes, if a read command was issued */

	if((command & IS_READ_COMMAND) != 0)
	{
		while((pHandle->statusFlag & GET_COMMAND_REQ) != 0);
		/* This means that this was a read command	*/
		*((int*) data) = pHandle->commandValue;
	}
}


void __attribute__((__interrupt__,no_auto_psv)) _DCIInterrupt(void)
{
	/* The interrupt routine will work on the next frame to be sent	
	 * So TGL_PRI_SEC_FRAME after toggling is 1, it means that
	 * a primary frame is being sent and secondary frame needs 
	 * needs to be prepared (if required). At this time, the DCI
	 * module is also reading the primary frame from the codec.*/
	 
	 int statusFlag; 
	 int actualCommand = DEFAULT_COMMAND;
	 int actualCommandValue = 0;
	 int recievedData;
	
	_DCIIF = 0;

	thisCodec->statusFlag ^= TGL_PRI_SEC_FRAME;
	statusFlag = thisCodec->statusFlag;

	/* TGL_PRI_SEC_FRAME = 1 - means that next ISR DCI will send out secondary frame.
	 * if TGL_PRI_SEC_FRAME = 0 - means the next ISR, DCI will send out primary frame */
	
	if(((statusFlag & GET_PRI_SEC_FRAME) != 0))
	{
		recievedData = RXBUF0;
		if((statusFlag & GET_CANSEND_CMD) == 0)
		{
			if(recievedData != 0) 
			{
				thisCodec->statusFlag |= SET_CANSEND_CMD;
			}
		}
				
		if((statusFlag & GET_COMMAND_REQ) != 0)
		{
			if((statusFlag & GET_COMMAND_SENT) != 0)
			{
				thisCodec->commandValue = recievedData;
				thisCodec->statusFlag &= CLR_COMMAND_REQ;
				thisCodec->statusFlag &= CLR_COMMAND_SENT;
			}
			else
			{
				actualCommand = thisCodec->command;
				actualCommandValue = thisCodec->commandValue;
				thisCodec->statusFlag |= SET_COMMAND_SENT;
			}
		}
		TXBUF0 = actualCommand | actualCommandValue;
	}
	else 
	{
		/* If here means the next frame will be a primary 
		 * frame. A secondary frame is being tranmitted
		 * Prepare audio data. Set the last bit of audio data
		 * if there is a  command request else clear the bit	*/
		thisCodec->activeInputBuffer[thisCodec->currentSampleIndex] = RXBUF0;
		TXBUF0 = thisCodec->activeOutputBuffer[thisCodec->currentSampleIndex] | 0x1;
		thisCodec->currentSampleIndex++;	
	}

	if(thisCodec->currentSampleIndex == thisCodec->currentFrameSize)
	{
		/* Transmitted one frame of data.
		 * Recieved one frame of data.
		 * Toggle the buffer indicator bit */
	
		thisCodec->statusFlag ^= TGL_BUFFER_IND;
		if((thisCodec->statusFlag &	GET_BUFFER_IND) != 0)
		{
			/* Buffer indicator is 1 means use buffer2	*/
			thisCodec->activeInputBuffer = thisCodec->inputBuffer2;
			thisCodec->activeOutputBuffer = thisCodec->outputBuffer2;
		}
		else
		{
			/* Buffer indicator is 0 means use buffer1	*/
			thisCodec->activeInputBuffer = thisCodec->inputBuffer1;
			thisCodec->activeOutputBuffer = thisCodec->outputBuffer1;
		}
		/* Reset the sample index and update the sample count	*/
		thisCodec->currentSampleIndex = 0;		
		thisCodec->currentFrameSize = thisCodec->newFrameSize ;
		thisCodec->statusFlag &= CLR_READ_BUSY;
		thisCodec->statusFlag &= CLR_WRITE_BUSY;
	}
}
